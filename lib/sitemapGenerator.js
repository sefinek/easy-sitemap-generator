const { JSDOM } = require('jsdom');
const urlModule = require('node:url');
const fs = require('node:fs/promises');
const path = require('node:path');
const { axios, version } = require('../services/axios.js');
const { escapeXml, normalizeUrl, calculatePriority } = require('../utils/xml.js');
const { logInfo, logSuccess, logError, logWarning } = require('../utils/kleur.js');

const VISITED_URLS = new Map();
const IGNORED_PATTERNS = ['cdn-cgi', '?referrer=', '&referrer=', '/signin/v2/usernamerecovery', '/lifecycle/flows/signup', 'join?return_to='];
const BASE_DELAY = 9000;

const shouldIncludeUrl = (url, baseUrl) => !IGNORED_PATTERNS.some(pattern => url.includes(pattern)) && url.startsWith(baseUrl);
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

const fetchUrl = async (url, retries = 0) => {
	try {
		logInfo(`GET ${url}`);

		const res = await axios.get(url);
		if (res.status === 200) {
			return res;
		} else {
			logWarning(`Non-200 status code (${res.status}) for URL: ${url}. Skipping...`);
			return null;
		}
	} catch (err) {
		if (err.response) {
			const statusCode = err.response.status;
			if (statusCode === 429) {
				const delayTime = BASE_DELAY * Math.pow(2, retries);
				logWarning(`429: Rate limit hit! Retrying in ${(delayTime / 1000).toFixed(2)}s... (Attempt ${retries + 1})`);
				await delay(delayTime);
				return fetchUrl(url, retries + 1);
			} else if (statusCode === 404) {
				logWarning('404: Not Found');
				return null;
			} else {
				logError(`${statusCode}: Failed to fetch! Skipping...`);
				return null;
			}
		} else {
			logError(`Failed to fetch ${url}. Unknown error: ${err.message}. Skipping...`);
			return null;
		}
	}
};

const crawl = async (url, baseUrl) => {
	const normalizedUrl = normalizeUrl(url);
	if (VISITED_URLS.has(normalizedUrl)) return;

	const res = await fetchUrl(normalizedUrl);
	if (!res) return;

	VISITED_URLS.set(normalizedUrl, { url: normalizedUrl });

	const { document } = new JSDOM(res.data).window;
	const links = Array.from(document.querySelectorAll('a[href]'))
		.map(link => urlModule.resolve(baseUrl, link.getAttribute('href')))
		.map(normalizeUrl)
		.filter(link => shouldIncludeUrl(link, baseUrl));

	logInfo(`${res.status}: Found ${links.length} urls`);

	for (const link of links) {
		await crawl(link, baseUrl);
	}

	VISITED_URLS.set(normalizedUrl, {
		url: normalizedUrl,
		lastmod: (res.headers['last-modified'] ? new Date(res.headers['last-modified']) : new Date()).toISOString(),
		priority: calculatePriority(normalizedUrl, baseUrl),
	});
};

const generateSitemap = async (baseUrl, destination = 'sitemap.xml') => {
	logInfo(`Starting crawl for base URL: ${baseUrl}`);

	await crawl(baseUrl, baseUrl);

	logInfo(`Generating sitemap with ${VISITED_URLS.size} URLs...`);
	// console.log(VISITED_URLS);

	const urls = Array.from(VISITED_URLS.values())
		.sort((a, b) => b.priority - a.priority);

	const sitemapContent = `<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by https://github.com/sefinek/easy-sitemap-generator v${version} at ${new Date().toISOString()} -->
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd">
${urls.map(({ url, priority, lastmod }) => `    <url>
        <loc>${escapeXml(url)}</loc>
        <lastmod>${lastmod}</lastmod>
        <priority>${priority?.toFixed(2) || 0.50}</priority>
    </url>`).join('\n')}
</urlset>`;

	const output = path.resolve(destination);
	await fs.writeFile(output, sitemapContent, 'utf8');
	logSuccess(`Sitemap has been generated at ${output}`);

	return sitemapContent;
};

module.exports = {
	generate: generateSitemap,
	version,
};